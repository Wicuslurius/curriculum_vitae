<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pensando en React</title>
    <link rel="stylesheet" href="./../../../assets/styles/css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  </head>
  <body>
    <header>
      <div class="nav-logo-container">
        <img src="./../../../assets/img/logo_cv.png" alt="logo_cv" class="nav-logo"/>
        <p class="nav-title">Documentacion</p>
      </div>
      <button class="open-menu" id="open"><i class="fa-solid fa-bars" style="color: white;"></i></button>
      <nav class="nav-bar" id="nav">    
        <button id="close" class="close-menu"><i class="fa-solid fa-x" style="color: white;"></i></button>
        <ul class="nav-list">
          <li><a href="./../../../index.html">Inicio</a></li>
          <li><a href="./../../documentation.html">Documentación</a></li>
          <li><a href="./../../certification.html">Certificaciones</a></li>
          <li><a href="./../../contact.html">Contacto</a></li>
        </ul>
      </nav>
    </header>
    <main class="principal-container">
      <section>
        <p class="principal-title">Pensando en React</p>
        <a href="./../../documentation.html" class="arrow-link"><i class="fa-solid fa-arrow-left arrow-left-icon" style="display: flex; justify-content: center; align-items: center;"></i></a>
        <div class="information-card">
          </br>
          <p>  
            React puede cambiar tu forma de pensar sobre los diseños que miras y las aplicaciones que creas. Cuando crear una interfaz de usuario con React, primero la dividirá en partes llamadas componentes . Luego,
            describirá los diferentes estados visuales para cada uno de sus componentes. Finalmente , conectará sus componentes para que los datos fluyan a través de ellos . En este tutorial , lo guiaremos a través
            del proceso de pensamiento para crear una tabla de datos de productos que permita realizar búsquedas con React.
          </p>
          <br>
          <p class="title-card">
            Empezar con la maqueta
          </p>
          <br>
          <p>
            Imagina que ya tienes una API JSON y una maqueta de un diseñador.
            La Api Json devuelve algunos datos que se ven así:
          </p>
          <br>
          <pre>
            [
              { category: "Fruits", price: "$1", stocked: true, name: "Apple" },
              { category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit" },
              { category: "Fruits", price: "$2", stocked: false, name: "Passionfruit" },
              { category: "Vegetables", price: "$2", stocked: true, name: "Spinach" },
              { category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin" },
              { category: "Vegetables", price: "$1", stocked: true, name: "Peas" }
            ]
          </pre>
          <br>
          <p>
            para implementar una interfaz de usuario en React, normalmente seguirá los mismos cinco pasos.
          </p>
          <br>
          <p>
            Paso1: dividir la interfaz de usuario en una jerarquía de componentes
          </p>
          <br>
          <p>
            Comience dibujando cuadros alrededor de cada componente y subcomponente en la maqueta y asígneles un nombre. si trabaja con un diseádor , es posible que ya haya nombrado estos componentes en su 
            herramienta de diseño. Pregúntales!
          </p>
          <br>
          <p>
            Dependiendo de su experiencia, puede pensar en dividir un diseño en componentes de diferentes maneras:
          </p>
          <br>
          <pre>
            Programación: use las mismas técnicas para decidir si debe crear una nueva función u objeto. 
              una de esas técnicas es el principio de responsabilidad única, es decir , un componente idealmente solo 
            debería hacer una cosa. Si termina creciendo , debe descomponerse en subcomponentes mas pequeños.
            Css: Considere para qué haría los selectores de clase.(Sin embargo, los componentes son un poco menos granulares).
            Diseño: Considere cómo organizaría las capas del diseño.
          </pre>
          <br>
          <p>
            Si su json está bien estructurado, a menudo encontrará que se asigna naturalmente a la estructura de componentes de su interfaz de usuario. Esto se debe a que la interfaz de usuario y los modelos de datos 
            suelen tener la misma arquitectura de información, es decir, la misma forma. Separe su interfaz de usuario en componentes , donde cada componente coincida con una parte de su modelo de datos.
          </p>
          <br>
          <p>
            hay cinco componentes en esta pantalla :
          </p>
          <br>
          <pre>
            1.FilterableProductTable(gris) contiene toda la aplicación.
            2.SearchBar(azul) recibe la entrada del usuario.
            3.ProductTable(lavanda) muestra y filtra la lista según la entrada del usuario.
            4.ProductCategoryRow(verde) muestraun encabezado para cada categoría.
            5.ProductRow(amarillo)muestra una fila para cada producto.
          </pre>
          <br>
          <p>
            Si observa ProducTable(lavanda), verá que el encabezado de la tabla(que contiene las etiquetas 'nombre' y 'precio')no es su propio componente. esta es una cuestión de preferencia, y puedes ir de cualquier 
            manera . para este ejemplo, es parte de ProductTable porque aparece dentro de la ProducTable lista de . Sin embargo, si este encabezado se vuelve complejo (por ejemplo, si agrega clasificación), puede
            moverlo a su propio ProducTableHeader componente.
          </p>
          <br>
          <p>
            Ahora que ha identificado los componentes en la maqueta, organícelos en una jerarquía. Los componentes que aparecen dentro de otro componente en la maqueta deben aparecer como elementos secundarios en la 
            jerarquía:
          </p>
          <br>
          <pre>
            ->FilterableProductTable
            ->SearchBar
            ->ProductTable
            ->ProductCategoryRow
            ->ProductRow
          </pre>
          <br>
          <p>
            Paso 2: Crear una versión estática en React
          </p>
          <br>
          <p>
            ahora que tiene su jerarquía de componentse, es hora de implementar su aplicación. El enfoque más sencillo es crear una versión que represente la interfaz de usuario de su modelo de datos sin agregar 
            ningunna interactividad... todavía! a menudo es más fácil crear primero la versión estática y luego agregar interactividad. Construir una versión estática requiere mucho escribir y no pensar, pero agregar
            interactividad requiere mucho pensar y no escribir mucho.
          </p>
          <br>
          <p>
            para crear una versión estática de su aplicación que represente su modelo de datos , querrá crear componentes que reutilicen otros componentes y pasen datos usando accesorios. Los accesorios son una forma
            de pasar datos de padre a hijo. (Si está familiarizado con el concepto de estado , no use estado en absoluto para crear esta version estática. El estado está reservado solo para la interactividad , es 
            decir , los datos que cambian con el tiempo. Dado que esta es una versión estática de la aplicación, no lo necesitas.)
          </p>
          <br>
          <p>
            Puede construir 'de arriba hacia abajo' comenzando con la construcción de los componentes más arriba en la jerarquía (como FilterableProductTable) o 'de abajo hacia arriba' trabajando desde los componentes
            más abajo(como ProductRow). En ejemplos más simples, generalmente es más fácil ir de arriba hacia abajo y en proyectos más grandes , es más fácil ir de abajo hacia arriba.
          </p>
          <br>
          <pre>
            function ProductCategoryRow({ category }) {
              return (
                &lt;tr&gt;
                  &lt;th colSpan="2"&gt;
                    {category}
                  &lt;/th&gt;
                &lt;/tr&gt;
              );
            }
          </pre>
          <br>
          <pre>
            function ProductRow({ product }) {
              const name = product.stocked ? product.name :
                &lt;span style={{ color: 'red' }}&gt;
                  {product.name}
                &lt;/span&gt;

              return (
                &lt;tr&gt;
                  &lt;td>{name}&lt;/td&gt;
                  &lt;td>{product.price}&lt;/td&gt;
                &lt;/tr&gt;
              );
            }
          </pre>
          <br>
          <pre>
            function ProductTable({ products }) {
              const rows = [];
              let lastCategory = null;

              products.forEach((product) => {
                if (product.category !== lastCategory) {
                  rows.push(
                    &lt;ProductCategoryRow
                      category={product.category}
                      key={product.category} /&gt;
                  );
                }
                rows.push(
                  &lt;ProductRow
                    product={product}
                    key={product.name} /&gt;
                );
                lastCategory = product.category;
              });

              return (
                &lt;table&gt;
                  &lt;thead&gt;
                    &lt;tr&gt;
                      &lt;th&gt;Name&lt;/th&gt;
                      &lt;th&gt;Price&lt;/th&gt;
                    &lt;/tr&gt;
                  &lt;/thead&gt;
                  &lt;tbody&gt;{rows}&lt;/tbody&gt;
                &lt;/table&gt;
              );
            }

            function SearchBar() {
              return (
                &lt;form&gt;
                  &lt;input type="text" placeholder="Search..." /&gt;
                  &lt;label&gt;
                    &lt;input type="checkbox" /&gt;
                    {' '}
                    Only show products in stock
                    &lt;/label&gt;
                    &lt;/form&gt;
              );
            }

            function FilterableProductTable({ products }) {
              return (
                &lt;div&gt;
                  &lt;SearchBar /&gt;
                  &lt;ProductTable products={products} /&gt;
                &lt;/div&gt;
              );
            }

            const PRODUCTS = [
              {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
              {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
              {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
              {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
              {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
              {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
            ];

            export default function App() {
              return &lt;FilterableProductTable products={PRODUCTS} /&gt;;
            }

          </pre>
          <br>
          <p>
            (Si este código parece intimidante, Primero realice el inicio rápido!)
          </p>
          <br>
          <p>
            Después de construir sus componentes , tendrá una biblioteca de componentes reutilizables que representan su modelo de datos. Debido a que esta es una aplicación estática, los componentes solo devolverán
            JSX. El componente en la parte superior de la jerarquía(FilterableProductTable) tomará su modelo de datos como accesorio. Esto se denomina flujo de datos unidireccional por que los datos fluyen hacia 
            abajo desde el componente de nivel superior hasta los que se encuentran en la parte inferior del árbol.
          </p>
          <br>
          <p>
            Trampa!!!-> En este pundo, no debe usar ningún valor de estado. Eso es para el siguiente paso!
          </p>
          <br>
          <p>
            Paso 3 Encuentre la representación mínima pero completa del estado de la interfaz de usuario 
          </p>
          <br>
          <p>
            para que la interfaz de usuario sea interactiva , debe permitir que los usuarios cambien su modelo de datos subyacente. Usará el estado para esto.
            Piense en el estado como el conjunto mínimo de datos cambiantes que su aplicación necesita recordar . El principio más importante para estructurar el estado es mantenerlo DRY(Don't Repeat Yourself).
            Calcule la representacion mínima absoluta del estado que necesita su aplicación y calcule todo lo demás a pedido. Por ejemplo, si está creando una lista de compras, pude almacenar los elementos como una 
            matriz en el estado . Si también desea mostrar la cantidad de elementos en la lista, no almacene la cantidad de elementos como otro valor de estado; en su lugar ,lea la longitud de su matriz.
          </p>
          <br>
          <p>
            Ahora piense en los datos de esta aplicación de ejemplo:
          </p>
          <br>
          <pre>
            1. la lista original de productos. 
            2. El texto de búsqueda que el usuario ha introducido
            3. El valor de la casilla
            4. La lista filtrada de productos
          </pre>
          <br>
          <p>
            Cuáles de estos son estatales? Identifica las que no lo son:
          </p>
          <br>
          <pre>
            Se mantiene invariable con el tiempo? Si es así, no es estatal.
            Se transmite de un padre a través de accesorios? Si es así, no es estatal.
            Puede calcularlo según el estado existente o los accesorios en su componente? Si es así, definitivamente no es estatal!
          </pre>
          <br>
          <p>
            lo que queda es probablemente el estado . 
          </p>
          <br>
          <p>
            Vamos a repasarlos uno por uno de nuevo:
          </p>
          <br>
          <pre>
            1. La lista original de productos se transmite como accesorios, por lo que no es estatal.
            2. El texto de búsqueda parece ser un estado, ya que cambia con el tiempo y no se puede calcular a partir de nada.
            3. El valor de la casilla de verificacion parece ser el estado , ya que cambia con el tiempo y no se puede calcular a partir de nada. 
            4. La lista filtrada de productos no es estatal por que se puede calcular tomando la lista original de productos y 
               filtrándola según el texto de búsqueda y el valor de la casilla de verificación.
          </pre>
          <br>
          <p>
            Esto significa que solo se indica el texto de búsqueda y el valor de la casilla de verificación, Bien hecho!
          </p>
          <br>
          <p class="title-card">
            Paso 4: Identifique dónde debería vivir su estado ----------------------------------------------------------
          </p>
          <br>
          <p>
            Después de identificar los datos de estado mínimos de su aplicación, debe identificar qué componentes es responsable de cambiar este estado o es el propietario del estado. Recuerde: React utiliza un flujo
            de datos unidireccional, pasando los datos por la jerarquía de componentes del componente principal al componente secundario. Puede que no quede claro de inmediato qué componente debe poseer qué estado . 
            Esto puede ser un desafío si eres nuevo en este concepto, pero puedes resolverlo siguiendo estos pasos!.
          </p>
          <br>
          <p>
            para cada parte del estado en su solicitud:
          </p>
          <br>
          <pre>
            1.Identifique cada componente que representa algo basado en ese estado. 
            2.Encuentre su componente principal común más cercano, un componente por encima de todos ellos en la jerarquía.
            3.Decide dónde debe vivir el estado:
            -> A menudo, puede poner el estado directamente en su padre común.
            -> También, puede poner el estado en algún componente por encima de su padre común.
            -> Si no puede encontrar un componente en el que tenga sentido poseer el estado, cree un nuevo componente únicamente para mantener 
              el estado y agréguelo en algún lugar de la jerarquía por encima del componente principal común.
            </pre>
            <br>
            <p>
              En el paso anterior, encontró dos piezas de estado en esta aplicación: el texto de entrada de búsqueda y el valor de la casilla de verificación. En este ejemplo, siempre aparecen juntas , por lo que
              tiene sentido colocarlas en el mismo lugar . 
            </p>
            <br>
            <p>
            Ahora repasemos nuestra estrategia para ellos:
            </p>
            <br>
            <p>
            ->1. Identifique los componentes que usan el estado:
            </p>
            <br>
            <p>
            ProductTable necesita filtrar la lista de productos según este estado (texto de búsqueda y valor de la casilla de virificación)
            SearchBar necesita mostrar ese estado (texto de búsqueda y valor de casilla de verificación).
            </p>
            <br>
            <pre>
            ->2.Encuentre su padre común: El primer componente padre que comparten ambos componentes es FilterableProductTable.
            ->3.Decida dónde vive el estado : mantendremos el texto de filtro y los valoress de estado verificados FliterableProductTable.
            </pre>
            <br>
            <p>
            Entonces los valores del estado vivirán en FilterableProductTable.
            </p>
            <br>
            <p>
            Agrega estado al componente con el useState(). los ganchos son funciones especiales que le permiten 'engancharse' a React. Agregue dos variables de estado en la parte superior FilterableProductTable y 
            especifique su estado inicial:
            </p>
            <br>
            <pre>
            function FilterableProductTable({ products }) {
              const [filterText, setFilterText] = useState('');
              const [inStockOnly, setInStockOnly] = useState(false);

            luego, pase filterText y inStockOnly y hacia ProducTable y SearchBar como apoyos:

            &lt;div&gt;
              &lt;SearchBar
                filterText={filterText}
                inStockOnly={inStockOnly} /&gt;
                &lt;ProductTable
                products={products}
                filterText={filterText}
                inStockOnly={inStockOnly} /&gt;
            &lt;/div&gt;

            Puede comenzar a ver cómo se comportará su aplicación. Edite el filterText valor inicial de useState('') 
            a useState('fruit') en código sandbox a continuación. Vera tanto el texto de entrada de búsqueda  como la actualización de la tabla:

            ---------------------------------------------------------------------------------------------------
            import { useState } from 'react';

            function FilterableProductTable({ products }) {
              const [filterText, setFilterText] = useState('');
              const [inStockOnly, setInStockOnly] = useState(false);

              return (
                &lt;div&gt;
                  &lt;SearchBar
                    filterText={filterText}
                    inStockOnly={inStockOnly} /&gt;
                  &lt;ProductTable
                    products={products}
                    filterText={filterText}
                    inStockOnly={inStockOnly} /&gt;
                &lt;/div&gt;
              );
            }

            function ProductCategoryRow({ category }) {
              return (
                &lt;tr&gt;
                &lt;th colSpan="2"&gt;
                    {category}
                    &lt;/th&gt;
                    &lt;/tr&gt;
              );
            }

            function ProductRow({ product }) {
              const name = product.stocked ? product.name :
                &lt;span style={{ color: 'red' }}&gt;
                  {product.name}
                &lt;/span&gt;;

              return (
                &lt;tr&gt;
                  &lt;td&gt;{name}&lt;/td&gt;
                  &lt;td&gt;{product.price}&lt;/td&gt;
                &lt;/tr&gt;
              );
            }

            function ProductTable({ products, filterText, inStockOnly }) {
              const rows = [];
              let lastCategory = null;

              products.forEach((product) => {
                if (
                  product.name.toLowerCase().indexOf(
                    filterText.toLowerCase()
                  ) === -1
                ) {
                  return;
                }
                if (inStockOnly && !product.stocked) {
                  return;
                }
                if (product.category !== lastCategory) {
                  rows.push(
                    &lt;ProductCategoryRow
                      category={product.category}
                      key={product.category} /&gt;
                  );
                }
                rows.push(
                  &lt;ProductRow
                    product={product}
                    key={product.name} /&gt;
                );
                lastCategory = product.category;
              });

              return (
                &lt;table&gt;
                  &lt;thead&gt;
                    &lt;tr&gt;
                      &lt;th&gt;Name&lt;/th&gt;
                      &lt;th&gt;Price&lt;/th&gt;
                    &lt;/tr&gt;
                  &lt;/thead&gt;
                  &lt;tbody&gt;{rows}&lt;/tbody&gt;
                &lt;/table&gt;
              );
            }

            function SearchBar({ filterText, inStockOnly }) {
              return (
                &lt;form&gt;
                  &lt;input
                    type="text"
                    value={filterText}
                    placeholder="Search..."/&gt;
                  &lt;label&gt;
                    &lt;input
                      type="checkbox"
                      checked={inStockOnly} /&gt;
                    {' '}
                    Only show products in stock
                  &lt;/label&gt;
                &lt;/form&gt;
              );
            }

            const PRODUCTS = [
              {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
              {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
              {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
              {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
              {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
              {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
            ];

            export default function App() {
              return &lt;FilterableProductTable products={PRODUCTS} /&gt;;
            }
            </pre>
            ----------------------------------------------------------------------------------------
          <br>
          <p>
            Tenga en cuenta que la edición del formulario aún no funciona. Hay un error de consola en el sanbox anterior que explica por qué:
          </p>
          <br>
          <p>
            En el sandbox anterior, ProductTable lea SearchBar los accesorios filtText y inStockOnly para represenar la tabla , la entrada y la casilla de virificación. Por ejemplo, así es como SearchBar re rellena
            el valor de entrada:
          </p>
          <br>
          <pre>
            function SearchBar({ filterText, inStockOnly }) {
              return (
                &lt;form&gt;
                  &lt;input
                    type="text"
                    value={filterText}
                    placeholder="Search&gt;
          </pre>
          <br>
          <p>
            Sin embargo, aún no ha agregado ningún código para responder a las acciones del usuario, como escribir.Este será tu último paso.
          </p>
          <br>
          <p>
            Paso 5 : Agregar flujo de datos inverso
          </p>
          <br>
          <p>
            Actualmente , su aplicación se presenta correctamente con accesorios y estado que fluye hacia abajo en la jerarquía. Pero para cambiar el estado de acuerdo con la entrada del usuario, deberá permitir que
            los datos fluyan en sentido contrario: los componentes del formulario en lo profundo de la jerarquía deben actualizar el estado en FilterableProductTable.
          </p>
          <br>
          <p>
            React hace que este flujo de datos sea explícito, pero requiere un poco más de escritura que el enlace de datos bidireccional. Si intenta escribir o marcar la casilla en el ejemplo anterior, verá que
            React ignora su entrada. Esto es intencinal. Al escribir &lt;inpunt value={filterText}&gt; , ha establecido que la value prop de input sea siempre igual al filterText estado pasado desde FilterableProductTable.
            Dado que filterText el estado nunca se establece , la entrada nunca cambia.
          </p>
          <br>
          <p>
            Desea que cada vez que el usuario cambie las entradas del formulario, el estado se actualice para reflejar esos cambios .El estado es propiedad de FilterableProductTable, por lo que solo puede llamrse setFilterText y setInStockOnly. Para permitir SearchBar que se actualice el FilterableProductTable estado , debe pasar estas funciones a SearchBar:
          </p>
          <br>
          <pre>
            function FilterableProductTable({ products }) {
              const [filterText, setFilterText] = useState('');
              const [inStockOnly, setInStockOnly] = useState(false);

              return ()
                &lt;div&gt;
                  &lt;SearchBar
                    filterText={filterText}
                    inStockOnly={inStockOnly}
                    onFilterTextChange={setFilterText}
                    onInStockOnlyChange={setInStockOnly} &gt;

            Dentro de SearchBar, agregará los onChange controladores de enventos y establecerá el estado principal a partir de ellos :

            &lt;input
              type="text"
              value={filterText}
              placeholder="Search..."
              onChange={(e) => onFilterTextChange(e.target.value)} /&gt;

            Ahora la aplicación funciona completamente!
            -------------------------------------------------------
            import { useState } from 'react';

            function FilterableProductTable({ products }) {
              const [filterText, setFilterText] = useState('');
              const [inStockOnly, setInStockOnly] = useState(false);

              return (
                &lt;div&gt;
                  &lt;SearchBar
                    filterText={filterText}
                    inStockOnly={inStockOnly}
                    onFilterTextChange={setFilterText}
                    onInStockOnlyChange={setInStockOnly} /&gt;
                  &lt;ProductTable
                    products={products}
                    filterText={filterText}
                    inStockOnly={inStockOnly} &gt;
                &lt;/div&gt;
              );
            }

            function ProductCategoryRow({ category }) {
              return (
                &lt;tr&gt;
                  &lt;th colSpan="2"&gt;
                    {category}
                  &lt;/th&gt;
                &lt;/tr&gt;
              );
            }

            function ProductRow({ product }) {
              const name = product.stocked ? product.name :
                &lt;span style={{ color: 'red' }}&gt;
                  {product.name}
                &lt;/span>;

              return (
                &lt;tr&gt;
                  &lt;td&gt;{name}&lt;/td&gt;
                  &lt;td&gt;{product.price}&lt;/td&gt;
                &lt;/tr>
              );
            }

            function ProductTable({ products, filterText, inStockOnly }) {
              const rows = [];
              let lastCategory = null;

              products.forEach((product) => {
                if (
                  product.name.toLowerCase().indexOf(
                    filterText.toLowerCase()
                  ) === -1
                ) {
                  return;
                }
                if (inStockOnly && !product.stocked) {
                  return;
                }
                if (product.category !== lastCategory) {
                  rows.push(
                    &lt;ProductCategoryRow
                      category={product.category}
                      key={product.category} /&gt;
                  );
                }
                rows.push(
                  &lt;ProductRow
                    product={product}
                    key={product.name} /&gt;
                );
                lastCategory = product.category;
              });

              return (
                &lt;table&gt;
                  &lt;thead&gt;
                    &lt;tr&gt;
                      &lt;th&gt;Name&lt;/th&gt;
                      &lt;th&gt;Price&lt;/th&gt;
                    &lt;/tr&gt;
                  &lt;/thead&gt;
                  &lt;tbody&gt;{rows}&lt;/tbody&gt;
                &lt;/table&gt;
              );
            }

            function SearchBar({
              filterText,
              inStockOnly,
              onFilterTextChange,
              onInStockOnlyChange
            }) {
              return (
                &lt;form&gt;
                  &lt;input
                    type="text"
                    value={filterText} placeholder="Search..."
                    onChange={(e) => onFilterTextChange(e.target.value)} /&gt;
                  &lt;label&gt;
                    &lt;input
                      type="checkbox"
                      checked={inStockOnly}
                      onChange={(e) => onInStockOnlyChange(e.target.checked)} /&gt;
                    {' '}
                    Only show products in stock
                  &lt;/label&gt;
                &lt;/form&gt;
              );
            }

            const PRODUCTS = [
              {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
              {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
              {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
              {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
              {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
              {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
            ];

            export default function App() {
              return &lt;FilterableProductTable products={PRODUCTS} /&gt;;
            }
          </pre>
        </div>
      </section>
    </main>
    <footer class="footer_container">
      <p style="margin: 30px 0;">© 2025 - Todos los derechos reservados</p>
    </footer>
    <script type="text/javascript" src="./../../../assets/javascript/main.js"></script>
  </body>
</html>